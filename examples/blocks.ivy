-- In Ivy, everything is an expression. This leads to transparent code
-- where symbols can be substituted with their values.

let age = 23;

-- The if expression returns a value.
let canSeeRatedR = if age >= 18 then true else false;

println(show(canSeeRatedR));

-- This is equivalent:
println(show(if age >= 18 then true else false));

-- ----------------------------------------------------------------------------

-- For imperative-style code, use `do` blocks. These are useful when you
-- need local variables inside a function. The last expression in a block
-- is its result.

-- Example: merge sort algorithm.

-- Step 1: merge function
-- Merges two sorted lists into one sorted list.
fn merge(lstA, lstB) => match lstA with
| [] -> lstB
| [h1 :: t1] -> match lstB with
  | [] -> lstA
  | [h2 :: t2] ->
    if h1 <= h2
    then h1 :: merge(t1, lstB)
    else h2 :: merge(lstA, t2)
  end
end;

-- Step 2: divide function
-- Splits a list into two halves.
fn divide(lst) => match lst with
| [] -> ([], [])
| [h :: tail] -> do {
    let (odds, evens) = divide(tail);
    (h :: evens, odds)
  }
end;

-- Step 3: mergesort function
fn mergesort(lst) => match lst with
| [] -> []
| [x] -> [x]
| _ -> do {
    let (evens, odds) = divide(lst);
    let sortedEvens = mergesort(evens);
    let sortedOdds = mergesort(odds);
    merge(sortedEvens, sortedOdds)
  }
end;

-- ----------------------------------------------------------------------------

-- An Ivy program is implicitly one big expression.
-- The following demonstrates functions for computing areas.

fn circleArea(radius) => 314 * radius * radius;

fn rectangleArea(length, width) => length * width;

let r = 6;
let l = 5;
let w = 10;

println("circleArea(" ++ show(r) ++ ") = " ++ show(circleArea(r)));
println("rectangleArea(" ++ show(l) ++ ", " ++ show(w) ++ ") = " ++ show(rectangleArea(l, w)));
