--- FUTURE MODULE (Requires Traits)
---
--- Binary Search Tree
---
--- A generic binary search tree implementation demonstrating
--- Ivy's type system, pattern matching, and traits.
---
--- This module requires the Ord trait for BST operations (compare, gt, lt, max).


module BinaryTree;

-- A binary tree is either empty (Leaf) or a node with a value and two subtrees.
type Tree<a> =
| Leaf
| Node(a, Tree<a>, Tree<a>)
;

-- =============================================================================
-- Trait Implementations
-- =============================================================================

impl Show for Tree<a> where Show<a> {
  fn show(Leaf) => "Leaf";
  fn show(Node(v, Leaf, Leaf)) => "Node(" ++ show(v) ++ ")";
  fn show(Node(v, l, r)) =>
    "Node(" ++ show(v) ++ ", " ++ show(l) ++ ", " ++ show(r) ++ ")";
}

impl Eq for Tree<a> where Eq<a> {
  fn eq(Leaf, Leaf) => true;
  fn eq(Node(v1, l1, r1), Node(v2, l2, r2)) =>
    eq(v1, v2) && eq(l1, l2) && eq(r1, r2);
  fn eq(_, _) => false;
}

-- =============================================================================
-- Construction
-- =============================================================================

-- Create an empty tree.
pub fn empty(): Tree<a> => Leaf;

-- Create a tree with a single value.
pub fn singleton(value: a): Tree<a> => Node(value, Leaf, Leaf);

-- Insert a value into a BST, maintaining the BST property.
-- Requires Ord trait for comparison.
pub fn insert(Leaf, value: a): Tree<a> => singleton(value);
pub fn insert(Node(v, left, right), value: a): Tree<a> =>
  match compare(value, v) with
  | Less -> Node(v, insert(left, value), right)
  | Equal -> Node(v, left, right)  -- No duplicates
  | Greater -> Node(v, left, insert(right, value))
  end;

-- Build a BST from a list of values.
pub fn fromList(values: [a]): Tree<a> =>
  foldl(insert, Leaf, values);

-- =============================================================================
-- Queries
-- =============================================================================

-- Check if a tree is empty.
pub fn isEmpty?(Leaf): Bool => true;
pub fn isEmpty?(Node(_, _, _)): Bool => false;

-- Count the number of nodes.
pub fn size(Leaf): Int => 0;
pub fn size(Node(_, left, right)): Int => 1 + size(left) + size(right);

-- Get the height of the tree.
pub fn height(Leaf): Int => 0;
pub fn height(Node(_, left, right)): Int => 1 + max(height(left), height(right));

-- Check if a value exists in the BST.
pub fn contains?(Leaf, _: a): Bool => false;
pub fn contains?(Node(v, left, right), value: a): Bool =>
  match compare(value, v) with
  | Less -> contains?(left, value)
  | Equal -> true
  | Greater -> contains?(right, value)
  end;

-- Find the minimum value (leftmost).
pub fn minimum(Leaf): Option<a> => None;
pub fn minimum(Node(v, Leaf, _)): Option<a> => Some(v);
pub fn minimum(Node(_, left, _)): Option<a> => minimum(left);

-- Find the maximum value (rightmost).
pub fn maximum(Leaf): Option<a> => None;
pub fn maximum(Node(v, _, Leaf)): Option<a> => Some(v);
pub fn maximum(Node(_, _, right)): Option<a> => maximum(right);

-- =============================================================================
-- Traversals
-- =============================================================================

-- In-order traversal (left, root, right) - produces sorted order for BST.
pub fn inorder(Leaf): [a] => [];
pub fn inorder(Node(v, left, right)): [a] =>
  inorder(left) ++ [v] ++ inorder(right);

-- Pre-order traversal (root, left, right).
pub fn preorder(Leaf): [a] => [];
pub fn preorder(Node(v, left, right)): [a] =>
  [v] ++ preorder(left) ++ preorder(right);

-- Post-order traversal (left, right, root).
pub fn postorder(Leaf): [a] => [];
pub fn postorder(Node(v, left, right)): [a] =>
  postorder(left) ++ postorder(right) ++ [v];

-- Convert to a sorted list (alias for inorder).
pub fn toList(tree: Tree<a>): [a] => inorder(tree);

-- =============================================================================
-- Transformations
-- =============================================================================

-- Map a function over all values in the tree.
-- Note: This may invalidate the BST property!
pub fn map(f: a -> b, Leaf): Tree<b> => Leaf;
pub fn map(f: a -> b, Node(v, left, right)): Tree<b> =>
  Node(f(v), map(f, left), map(f, right));

-- Fold over the tree in-order.
pub fn fold(f: b -> a -> b, acc: b, Leaf): b => acc;
pub fn fold(f: b -> a -> b, acc: b, Node(v, left, right)): b => do {
  let acc1 = fold(f, acc, left);
  let acc2 = f(acc1, v);
  fold(f, acc2, right)
};

-- =============================================================================
-- BST Validation
-- =============================================================================

-- Check if a tree satisfies the BST property.
pub fn isBST?(tree: Tree<a>): Bool =>
  isBSTHelper(tree, None, None);

fn isBSTHelper(Leaf, _: Option<a>, _: Option<a>): Bool => true;
fn isBSTHelper(Node(v, left, right), minBound: Option<a>, maxBound: Option<a>): Bool => do {
  let aboveMin = match minBound with
  | None -> true
  | Some(min) -> gt(v, min)
  end;

  let belowMax = match maxBound with
  | None -> true
  | Some(max) -> lt(v, max)
  end;

  aboveMin && belowMax &&
    isBSTHelper(left, minBound, Some(v)) &&
    isBSTHelper(right, Some(v), maxBound)
};
