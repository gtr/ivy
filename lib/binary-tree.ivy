
-------------------------------------------------------------------------------
--
-- Package      : bst
-- Author       : Gerardo Torres Castro
-- Date         : Septermber 2, 2022
-- License      : GNU Public License
--
-- T generic implementation of a binary search tree. 
--
------------------------------------------------------------------------------

package bst;

-- --------------------------------------------------------
-- Tree data type definition and trait implementations
-- --------------------------------------------------------

--- Tree is a generic binary search tree. It is a data type which can come in 
--- one of two varieties: a `Leaf`, which does not contain any further data; 
--- and a `Node` which is defined as a struct which takes a value of type `T`,
--- and two children, each of type `Tree<T>`. 
data Tree<T> (
    | Leaf 
    | Node :: struct (
        value :: T,
        left  :: Tree<T>,
        right :: Tree<T>
    )
);

--- Implements the `Equal` Trait for a Binary Tree. It relies on the assumption
--- that the `value :: T` field also has an implementation for the Equal trait. It will
--- allow you to write the following:
---
---     > let tree1 = Node("b", singleton("a"), singleton("c"));
---     > let tree2 = Node("b", singleton("a"), singleton("c"));
---     > :t tree1
---     tree1 :: Tree<String>
---     > tree1 == tree2
---     True;
---
impl Equal for Tree<T> (
    fn __==__ :: (Tree<T>, Tree<T>) -> Bool;
    fn __==__ (Leaf, Leaf)   => True ;
    fn __==__ (Leaf, ____)   => False ;
    fn __==__ (____, Leaf)   => False ;
    fn __==__ (left, right)  => 
        if __==__(left.value, right.value) 
        then __==__(left.left, right.left) && __==__(left.right, right.right) 
        else False;
);

--- Show Trait for a Binary Tree. It relies on the assumption that the 
--- `value :: T` field also has an implementation for the Show trait. 
--- Example:
---
---     > let tree = Node(2, singleton(1), singleton(2))
---     > println(tree);
---     <Node: 2, <Node: 1>, <Node: 3>>
--- 
impl Show for Tree<T> (
    fn __show__                         :: Tree<T> -> String
    fn __show__ (Leaf)                  => "<Leaf>";
    fn __show__ (Node(val, Leaf, Leaf)) => "<Node: " + __show__(val) + ">";
    fn __show__ (Node(val, l, Leaf))    => 
        "<Node: " + __show__(val) + ", "    + __show__(r) + ", _>";
    fn __show__ (Node(val, Leaf, r))    => 
        "<Node: " + __show__(val) + ", _, " + __show__(r) + ">";
    fn __show__ (Node(val, l, r))       => 
        "<Node: " + __show__(val) + ", "    + __show__(l) + ", " + __show__(r) + ">";
);

-- --------------------------------------------------------
-- Tree methods
-- --------------------------------------------------------

--- Returns a single Node initialized with a given value and no children.
pub fn singleton :: T -> Tree ;
pub fn singleton (value) => Node(value, Leaf, Leaf);

--- Determines if the given tree is a binary search tree, i.e. for all nodes in
--- the binary tree, the values to the left of the current node are less than 
--- the value of the current node and all the values to the right of the 
--- current node are greater than or equal to the value of the current node.
pub fn bST? :: Tree -> Bool ;
pub fn bST? (tree)  => first(bstHelper?(tree));

fn bstHelper? :: Tree<A> -> (Bool, A, A) ;
fn bstHelper? (Leaf) => (True, LARGEST, SMALLEST);
fn bstHelper? (Node(val, l, r)) => do {
    let (bool_l, min_l, max_l) = bstHelper?(l);
    let (bool_r, min_r, max_r) = bstHelper?(r);

    return match (max_l < val) && (val <= min_r) with (
        | True  -> (True, min_l, max_r)
        | False -> (False, min_l, max_r)
    );
};

--- Returns a new binary tree with a `value` inserted in the correct place.
pub fn insert :: (Tree<T>, T) -> Tree<T> ;
pub fn insert (Leaf, value) => singleton(value);
pub fn insert (node, value) => match (value, node.value) with (
    | LT -> Node(node.value, insert(node.left, value), node.right)
    | EQ -> node
    | GT -> Node(node.value, node.left, insert(node.right, value))
);

--- Determines weather a given `value` exists in the given binary tree.
pub fn containsValue? :: (Tree<T> , T) -> Bool ;
pub fn containsValue? (Leaf, value) => False ;
pub fn containsValue? (node, value) => match __compare__(value, node.value) with (
    | Less    -> containsValue?(node.left, value)
    | Equal   -> True
    | Greater -> containsValue?(node.right, value)
);

--- Given a tree of type `Tree<T>` and a function `func` of type `T -> U`, 
--- treeMap returns a new tree of type `Tree<U>` with all the values in the new
--- tree generated by applying the function `func` to all the values in the old
--- tree. Note that this may mess up the tree's ordered values.
pub fn treeMap :: (Tree<T>, T -> U) -> Tree<U>;
pub fn treeMap (Leaf, func) => Leaf;
pub fn treeMap (Node(value, left, right), func) => 
    Node(func(value), treeMap(left, func), treeMap(right, func));
