--------------------------------------------------------------------------------
---
--- Package      : prelude
--- Author       : Gerardo Torres Castro
--- Date         : August 30, 2022
--- License      : GNU Public License
---
--- The Ivy programming language standard prelude, which is automatically loaded
--- for all ivy programs invoked from the ivy REPL and the ivy compiler. 
---
--- Some base data types and functions (such as those dealing with I/O or time)
--- are implemented using Rust. To disable the ivy compiler from automatically
--- loading the prelude, run with the `--no-prelude` option.
---
-------------------------------------------------------------------------------

module Prelude;

-- =============================================================================
-- Primitive Types (implemented in Rust)
-- =============================================================================

-- These types are built into the runtime. They cannot be defined in Ivy.
-- Phase 1: Bool, Int, String, ()
-- Phase 3: Char
-- Future:  Float

-- =============================================================================
-- Core Sum Types
-- =============================================================================

-- Ordering represents the result of comparing two values.
type Ordering =
| Less
| Equal
| Greater
;

-- Option represents a value that may or may not exist.
-- Use this instead of null/nil.
type Option<a> =
| None
| Some(a)
;

-- Result represents a computation that may fail.
-- Use this instead of exceptions.
type Result<T, E> =
| Ok(T)
| Err(E)
;

-- =============================================================================
-- Core Traits
-- =============================================================================

-- Show: Convert a value to its string representation.
trait Show<a> {
  fn show(x: a): String;
}

-- Eq: Structural equality.
trait Eq<a> {
  fn eq(x: a, y: a): Bool;

  -- Default implementation
  fn neq(x: a, y: a): Bool => !(eq(x, y));
}

-- Ord: Total ordering. Requires Eq.
trait Ord<a> {
  fn compare(x: a, y: a): Ordering;

  -- Default implementations using compare
  fn lt(x: a, y: a): Bool => match compare(x, y) with
  | Less -> true
  | _ -> false
  end;

  fn le(x: a, y: a): Bool => match compare(x, y) with
  | Greater -> false
  | _ -> true
  end;

  fn gt(x: a, y: a): Bool => match compare(x, y) with
  | Greater -> true
  | _ -> false
  end;

  fn ge(x: a, y: a): Bool => match compare(x, y) with
  | Less -> false
  | _ -> true
  end;

  fn max(x: a, y: a): a => if gt(x, y) then x else y;
  fn min(x: a, y: a): a => if lt(x, y) then x else y;
}

-- =============================================================================
-- Trait Implementations for Primitives
-- =============================================================================

-- Note: These are actually implemented in Rust, but shown here for reference.

impl Show for Bool {
  fn show(true) => "true";
  fn show(false) => "false";
}

impl Show for Int {
  fn show(n) => __intToString(n);  -- Rust builtin
}

impl Show for String {
  fn show(s) => s;
}

impl Show for Ordering {
  fn show(Less) => "Less";
  fn show(Equal) => "Equal";
  fn show(Greater) => "Greater";
}

impl Show for Option<a> where Show<a> {
  fn show(None) => "None";
  fn show(Some(x)) => "Some(" ++ show(x) ++ ")";
}

impl Show for Result<T, E> where Show<T>, Show<E> {
  fn show(Ok(x)) => "Ok(" ++ show(x) ++ ")";
  fn show(Err(e)) => "Err(" ++ show(e) ++ ")";
}

impl Eq for Bool {
  fn eq(true, true) => true;
  fn eq(false, false) => true;
  fn eq(_, _) => false;
}

impl Ord for Bool {
  fn compare(false, true) => Less;
  fn compare(true, false) => Greater;
  fn compare(_, _) => Equal;
}

impl Eq for Option<a> where Eq<a> {
  fn eq(None, None) => true;
  fn eq(Some(x), Some(y)) => eq(x, y);
  fn eq(_, _) => false;
}

-- =============================================================================
-- Boolean Functions
-- =============================================================================

fn not(true): Bool => false;
fn not(false): Bool => true;

-- =============================================================================
-- Option Functions
-- =============================================================================

fn some?(None): Bool => false;
fn some?(Some(_)): Bool => true;

fn none?(opt) => !some?(opt);

fn unwrap(Some(x)) => x;
-- Note: unwrap(None) is a runtime error

fn unwrapOr(None, default) => default;
fn unwrapOr(Some(x), _) => x;

fn mapOption(f, None) => None;
fn mapOption(f, Some(x)) => Some(f(x));

fn flatMapOption(f, None) => None;
fn flatMapOption(f, Some(x)) => f(x);

-- =============================================================================
-- Result Functions
-- =============================================================================

fn ok?(Ok(_)): Bool => true;
fn ok?(Err(_)): Bool => false;

fn err?(r) => !ok?(r);

fn unwrapOk(Ok(x)) => x;
-- Note: unwrapOk(Err(_)) is a runtime error

fn unwrapErr(Err(e)) => e;
-- Note: unwrapErr(Ok(_)) is a runtime error

fn mapOk(f: T -> U, Ok(x)): Result<U, E> => Ok(f(x));
fn mapOk(f: T -> U, Err(e)): Result<U, E> => Err(e);

fn mapErr(f: E -> F, Ok(x)): Result<T, F> => Ok(x);
fn mapErr(f: E -> F, Err(e)): Result<T, F> => Err(f(e));

-- =============================================================================
-- List Functions
-- =============================================================================

fn head([]): Option<a> => None;
fn head([x :: _]): Option<a> => Some(x);

fn tail([]): Option<[a]> => None;
fn tail([_ :: xs]): Option<[a]> => Some(xs);

fn length([]): Int => 0;
fn length([_ :: xs]): Int => 1 + length(xs);

fn isEmpty?([]): Bool => true;
fn isEmpty?([_ :: _]): Bool => false;

fn map(f: a -> b, []): [b] => [];
fn map(f: a -> b, [x :: xs]): [b] => f(x) :: map(f, xs);

fn filter(pred: a -> Bool, []): [a] => [];
fn filter(pred: a -> Bool, [x :: xs]): [a] =>
  if pred(x) then x :: filter(pred, xs) else filter(pred, xs);

fn foldl(f: b -> a -> b, acc: b, []): b => acc;
fn foldl(f: b -> a -> b, acc: b, [x :: xs]): b => foldl(f, f(acc, x), xs);

fn foldr(f: a -> b -> b, acc: b, []): b => acc;
fn foldr(f: a -> b -> b, acc: b, [x :: xs]): b => f(x, foldr(f, acc, xs));

fn reverse(xs: [a]): [a] => foldl(fn (acc, x) => x :: acc, [], xs);

fn concat([], ys: [a]): [a] => ys;
fn concat([x :: xs], ys: [a]): [a] => x :: concat(xs, ys);

fn any(pred: a -> Bool, []): Bool => false;
fn any(pred: a -> Bool, [x :: xs]): Bool =>
  if pred(x) then true else any(pred, xs);

fn all(pred: a -> Bool, []): Bool => true;
fn all(pred: a -> Bool, [x :: xs]): Bool =>
  if pred(x) then all(pred, xs) else false;

fn take(0, _): [a] => [];
fn take(_, []): [a] => [];
fn take(n: Int, [x :: xs]): [a] => x :: take(n - 1, xs);

fn drop(0, xs: [a]): [a] => xs;
fn drop(_, []): [a] => [];
fn drop(n: Int, [_ :: xs]): [a] => drop(n - 1, xs);

-- =============================================================================
-- I/O Functions (implemented in Rust)
-- =============================================================================

-- These functions are built into the runtime as builtins:
-- print: a -> ()
-- println: a -> ()
-- show: a -> String
-- (readLine and readInt are not yet implemented)

-- =============================================================================
-- Utility Functions
-- =============================================================================

fn id(x: a): a => x;

fn const(x: a, _: b): a => x;

fn flip(f: a -> b -> c): b -> a -> c => fn (y, x) => f(x, y);

fn compose(f: b -> c, g: a -> b): a -> c => fn (x) => f(g(x));

-- Pipe operator helper (use with infix |>)
fn pipe(x: a, f: a -> b): b => f(x);
