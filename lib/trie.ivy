
FUTURE MODULE - Requires Map type

-- Trie (Prefix Tree)
--
-- A trie data structure for efficient string storage and prefix matching.
-- Commonly used for autocomplete and spell-checking.
-- 
-- This module requires the Map<K, V> type which is not yet implemented.


module Trie;

-- Note: This implementation assumes a Map type is available.
-- Map would be implemented in Rust or as a separate module.

-- A trie node contains a map of children and a flag indicating if it's a word end.
type Trie = {
  children: Map<Char, Trie>,
  isWord: Bool
};

-- =============================================================================
-- Construction
-- =============================================================================

-- Create an empty trie.
pub fn empty(): Trie => Trie {
  children: Map.empty(),
  isWord: false
};

-- Insert a word into the trie.
pub fn insert(trie: Trie, word: String): Trie =>
  insertChars(trie, toChars(word));

fn insertChars(trie: Trie, []): Trie =>
  { trie | isWord: true };

fn insertChars(trie: Trie, [c | cs]): Trie => do {
  let child = match Map.get(trie.children, c) with
  | None -> empty()
  | Some(t) -> t
  end;

  let newChild = insertChars(child, cs);
  let newChildren = Map.insert(trie.children, c, newChild);

  { trie | children: newChildren }
};

-- Insert multiple words.
pub fn insertAll(trie: Trie, []): Trie => trie;
pub fn insertAll(trie: Trie, [word | words]): Trie =>
  insertAll(insert(trie, word), words);

-- Build a trie from a list of words.
pub fn fromList(words: [String]): Trie => insertAll(empty(), words);

-- =============================================================================
-- Queries
-- =============================================================================

-- Check if the trie contains an exact word.
pub fn contains?(trie: Trie, word: String): Bool =>
  containsChars?(trie, toChars(word));

fn containsChars?(trie: Trie, []): Bool => trie.isWord;
fn containsChars?(trie: Trie, [c | cs]): Bool =>
  match Map.get(trie.children, c) with
  | None -> false
  | Some(child) -> containsChars?(child, cs)
  end;

-- Check if any word in the trie starts with the given prefix.
pub fn hasPrefix?(trie: Trie, prefix: String): Bool =>
  match findNode(trie, prefix) with
  | None -> false
  | Some(_) -> true
  end;

-- Find the trie node at the end of a prefix path.
fn findNode(trie: Trie, prefix: String): Option<Trie> =>
  findNodeChars(trie, toChars(prefix));

fn findNodeChars(trie: Trie, []): Option<Trie> => Some(trie);
fn findNodeChars(trie: Trie, [c | cs]): Option<Trie> =>
  match Map.get(trie.children, c) with
  | None -> None
  | Some(child) -> findNodeChars(child, cs)
  end;

-- =============================================================================
-- Autocomplete
-- =============================================================================

-- Get all words that start with the given prefix.
pub fn autocomplete(trie: Trie, prefix: String): [String] =>
  match findNode(trie, prefix) with
  | None -> []
  | Some(node) -> do {
      let suffixes = collectWords(node, "");
      map(fn (s) => prefix ++ s, suffixes)
    }
  end;

-- Collect all words reachable from a node.
fn collectWords(trie: Trie, current: String): [String] => do {
  let words = if trie.isWord then [current] else [];
  let childWords = Map.foldl(
    fn (acc, c, child) => acc ++ collectWords(child, current ++ charToString(c)),
    [],
    trie.children
  );
  words ++ childWords
};

-- =============================================================================
-- Statistics
-- =============================================================================

-- Count the number of words in the trie.
pub fn wordCount(trie: Trie): Int => do {
  let count = if trie.isWord then 1 else 0;
  let childCounts = Map.foldl(
    fn (acc, _, child) => acc + wordCount(child),
    0,
    trie.children
  );
  count + childCounts
};

-- Count the total number of nodes.
pub fn nodeCount(trie: Trie): Int =>
  1 + Map.foldl(fn (acc, _, child) => acc + nodeCount(child), 0, trie.children);

-- =============================================================================
-- Helper Functions
-- =============================================================================

-- Convert string to list of chars (would be builtin).
fn toChars(s: String): [Char] => __stringToChars(s);

-- Convert char to single-char string (would be builtin).
fn charToString(c: Char): String => __charToString(c);
